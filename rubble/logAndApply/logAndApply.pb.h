// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logAndApply.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_logAndApply_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_logAndApply_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_logAndApply_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_logAndApply_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_logAndApply_2eproto;
namespace logapply {
class DeleteFile;
class DeleteFileDefaultTypeInternal;
extern DeleteFileDefaultTypeInternal _DeleteFile_default_instance_;
class DeleteFiles;
class DeleteFilesDefaultTypeInternal;
extern DeleteFilesDefaultTypeInternal _DeleteFiles_default_instance_;
class EditLists;
class EditListsDefaultTypeInternal;
extern EditListsDefaultTypeInternal _EditLists_default_instance_;
class EditLists_EditList;
class EditLists_EditListDefaultTypeInternal;
extern EditLists_EditListDefaultTypeInternal _EditLists_EditList_default_instance_;
class EditLists_EditList_VersionEdit;
class EditLists_EditList_VersionEditDefaultTypeInternal;
extern EditLists_EditList_VersionEditDefaultTypeInternal _EditLists_EditList_VersionEdit_default_instance_;
class NewFile;
class NewFileDefaultTypeInternal;
extern NewFileDefaultTypeInternal _NewFile_default_instance_;
class NewFile_FileMetaData;
class NewFile_FileMetaDataDefaultTypeInternal;
extern NewFile_FileMetaDataDefaultTypeInternal _NewFile_FileMetaData_default_instance_;
class NewFile_FileMetaData_FileDescriptor;
class NewFile_FileMetaData_FileDescriptorDefaultTypeInternal;
extern NewFile_FileMetaData_FileDescriptorDefaultTypeInternal _NewFile_FileMetaData_FileDescriptor_default_instance_;
class NewFiles;
class NewFilesDefaultTypeInternal;
extern NewFilesDefaultTypeInternal _NewFiles_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace logapply
PROTOBUF_NAMESPACE_OPEN
template<> ::logapply::DeleteFile* Arena::CreateMaybeMessage<::logapply::DeleteFile>(Arena*);
template<> ::logapply::DeleteFiles* Arena::CreateMaybeMessage<::logapply::DeleteFiles>(Arena*);
template<> ::logapply::EditLists* Arena::CreateMaybeMessage<::logapply::EditLists>(Arena*);
template<> ::logapply::EditLists_EditList* Arena::CreateMaybeMessage<::logapply::EditLists_EditList>(Arena*);
template<> ::logapply::EditLists_EditList_VersionEdit* Arena::CreateMaybeMessage<::logapply::EditLists_EditList_VersionEdit>(Arena*);
template<> ::logapply::NewFile* Arena::CreateMaybeMessage<::logapply::NewFile>(Arena*);
template<> ::logapply::NewFile_FileMetaData* Arena::CreateMaybeMessage<::logapply::NewFile_FileMetaData>(Arena*);
template<> ::logapply::NewFile_FileMetaData_FileDescriptor* Arena::CreateMaybeMessage<::logapply::NewFile_FileMetaData_FileDescriptor>(Arena*);
template<> ::logapply::NewFiles* Arena::CreateMaybeMessage<::logapply::NewFiles>(Arena*);
template<> ::logapply::Response* Arena::CreateMaybeMessage<::logapply::Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace logapply {

// ===================================================================

class Response PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:logapply.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class EditLists_EditList_VersionEdit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.EditLists.EditList.VersionEdit) */ {
 public:
  inline EditLists_EditList_VersionEdit() : EditLists_EditList_VersionEdit(nullptr) {}
  virtual ~EditLists_EditList_VersionEdit();

  EditLists_EditList_VersionEdit(const EditLists_EditList_VersionEdit& from);
  EditLists_EditList_VersionEdit(EditLists_EditList_VersionEdit&& from) noexcept
    : EditLists_EditList_VersionEdit() {
    *this = ::std::move(from);
  }

  inline EditLists_EditList_VersionEdit& operator=(const EditLists_EditList_VersionEdit& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditLists_EditList_VersionEdit& operator=(EditLists_EditList_VersionEdit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EditLists_EditList_VersionEdit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditLists_EditList_VersionEdit* internal_default_instance() {
    return reinterpret_cast<const EditLists_EditList_VersionEdit*>(
               &_EditLists_EditList_VersionEdit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EditLists_EditList_VersionEdit& a, EditLists_EditList_VersionEdit& b) {
    a.Swap(&b);
  }
  inline void Swap(EditLists_EditList_VersionEdit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditLists_EditList_VersionEdit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditLists_EditList_VersionEdit* New() const final {
    return CreateMaybeMessage<EditLists_EditList_VersionEdit>(nullptr);
  }

  EditLists_EditList_VersionEdit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditLists_EditList_VersionEdit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditLists_EditList_VersionEdit& from);
  void MergeFrom(const EditLists_EditList_VersionEdit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditLists_EditList_VersionEdit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.EditLists.EditList.VersionEdit";
  }
  protected:
  explicit EditLists_EditList_VersionEdit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddedFieldNumber = 1,
    kDelsFieldNumber = 2,
  };
  // .logapply.NewFiles added = 1;
  bool has_added() const;
  private:
  bool _internal_has_added() const;
  public:
  void clear_added();
  const ::logapply::NewFiles& added() const;
  ::logapply::NewFiles* release_added();
  ::logapply::NewFiles* mutable_added();
  void set_allocated_added(::logapply::NewFiles* added);
  private:
  const ::logapply::NewFiles& _internal_added() const;
  ::logapply::NewFiles* _internal_mutable_added();
  public:
  void unsafe_arena_set_allocated_added(
      ::logapply::NewFiles* added);
  ::logapply::NewFiles* unsafe_arena_release_added();

  // .logapply.DeleteFiles dels = 2;
  bool has_dels() const;
  private:
  bool _internal_has_dels() const;
  public:
  void clear_dels();
  const ::logapply::DeleteFiles& dels() const;
  ::logapply::DeleteFiles* release_dels();
  ::logapply::DeleteFiles* mutable_dels();
  void set_allocated_dels(::logapply::DeleteFiles* dels);
  private:
  const ::logapply::DeleteFiles& _internal_dels() const;
  ::logapply::DeleteFiles* _internal_mutable_dels();
  public:
  void unsafe_arena_set_allocated_dels(
      ::logapply::DeleteFiles* dels);
  ::logapply::DeleteFiles* unsafe_arena_release_dels();

  // @@protoc_insertion_point(class_scope:logapply.EditLists.EditList.VersionEdit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::logapply::NewFiles* added_;
  ::logapply::DeleteFiles* dels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class EditLists_EditList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.EditLists.EditList) */ {
 public:
  inline EditLists_EditList() : EditLists_EditList(nullptr) {}
  virtual ~EditLists_EditList();

  EditLists_EditList(const EditLists_EditList& from);
  EditLists_EditList(EditLists_EditList&& from) noexcept
    : EditLists_EditList() {
    *this = ::std::move(from);
  }

  inline EditLists_EditList& operator=(const EditLists_EditList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditLists_EditList& operator=(EditLists_EditList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EditLists_EditList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditLists_EditList* internal_default_instance() {
    return reinterpret_cast<const EditLists_EditList*>(
               &_EditLists_EditList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EditLists_EditList& a, EditLists_EditList& b) {
    a.Swap(&b);
  }
  inline void Swap(EditLists_EditList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditLists_EditList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditLists_EditList* New() const final {
    return CreateMaybeMessage<EditLists_EditList>(nullptr);
  }

  EditLists_EditList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditLists_EditList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditLists_EditList& from);
  void MergeFrom(const EditLists_EditList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditLists_EditList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.EditLists.EditList";
  }
  protected:
  explicit EditLists_EditList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EditLists_EditList_VersionEdit VersionEdit;

  // accessors -------------------------------------------------------

  enum : int {
    kVersionEditFieldNumber = 1,
  };
  // repeated .logapply.EditLists.EditList.VersionEdit version_edit = 1;
  int version_edit_size() const;
  private:
  int _internal_version_edit_size() const;
  public:
  void clear_version_edit();
  ::logapply::EditLists_EditList_VersionEdit* mutable_version_edit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList_VersionEdit >*
      mutable_version_edit();
  private:
  const ::logapply::EditLists_EditList_VersionEdit& _internal_version_edit(int index) const;
  ::logapply::EditLists_EditList_VersionEdit* _internal_add_version_edit();
  public:
  const ::logapply::EditLists_EditList_VersionEdit& version_edit(int index) const;
  ::logapply::EditLists_EditList_VersionEdit* add_version_edit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList_VersionEdit >&
      version_edit() const;

  // @@protoc_insertion_point(class_scope:logapply.EditLists.EditList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList_VersionEdit > version_edit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class EditLists PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.EditLists) */ {
 public:
  inline EditLists() : EditLists(nullptr) {}
  virtual ~EditLists();

  EditLists(const EditLists& from);
  EditLists(EditLists&& from) noexcept
    : EditLists() {
    *this = ::std::move(from);
  }

  inline EditLists& operator=(const EditLists& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditLists& operator=(EditLists&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EditLists& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditLists* internal_default_instance() {
    return reinterpret_cast<const EditLists*>(
               &_EditLists_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EditLists& a, EditLists& b) {
    a.Swap(&b);
  }
  inline void Swap(EditLists* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditLists* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditLists* New() const final {
    return CreateMaybeMessage<EditLists>(nullptr);
  }

  EditLists* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditLists>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditLists& from);
  void MergeFrom(const EditLists& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditLists* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.EditLists";
  }
  protected:
  explicit EditLists(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EditLists_EditList EditList;

  // accessors -------------------------------------------------------

  enum : int {
    kEditListFieldNumber = 1,
  };
  // repeated .logapply.EditLists.EditList edit_list = 1;
  int edit_list_size() const;
  private:
  int _internal_edit_list_size() const;
  public:
  void clear_edit_list();
  ::logapply::EditLists_EditList* mutable_edit_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList >*
      mutable_edit_list();
  private:
  const ::logapply::EditLists_EditList& _internal_edit_list(int index) const;
  ::logapply::EditLists_EditList* _internal_add_edit_list();
  public:
  const ::logapply::EditLists_EditList& edit_list(int index) const;
  ::logapply::EditLists_EditList* add_edit_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList >&
      edit_list() const;

  // @@protoc_insertion_point(class_scope:logapply.EditLists)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList > edit_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class NewFile_FileMetaData_FileDescriptor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.NewFile.FileMetaData.FileDescriptor) */ {
 public:
  inline NewFile_FileMetaData_FileDescriptor() : NewFile_FileMetaData_FileDescriptor(nullptr) {}
  virtual ~NewFile_FileMetaData_FileDescriptor();

  NewFile_FileMetaData_FileDescriptor(const NewFile_FileMetaData_FileDescriptor& from);
  NewFile_FileMetaData_FileDescriptor(NewFile_FileMetaData_FileDescriptor&& from) noexcept
    : NewFile_FileMetaData_FileDescriptor() {
    *this = ::std::move(from);
  }

  inline NewFile_FileMetaData_FileDescriptor& operator=(const NewFile_FileMetaData_FileDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewFile_FileMetaData_FileDescriptor& operator=(NewFile_FileMetaData_FileDescriptor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewFile_FileMetaData_FileDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewFile_FileMetaData_FileDescriptor* internal_default_instance() {
    return reinterpret_cast<const NewFile_FileMetaData_FileDescriptor*>(
               &_NewFile_FileMetaData_FileDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewFile_FileMetaData_FileDescriptor& a, NewFile_FileMetaData_FileDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(NewFile_FileMetaData_FileDescriptor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewFile_FileMetaData_FileDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewFile_FileMetaData_FileDescriptor* New() const final {
    return CreateMaybeMessage<NewFile_FileMetaData_FileDescriptor>(nullptr);
  }

  NewFile_FileMetaData_FileDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewFile_FileMetaData_FileDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewFile_FileMetaData_FileDescriptor& from);
  void MergeFrom(const NewFile_FileMetaData_FileDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewFile_FileMetaData_FileDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.NewFile.FileMetaData.FileDescriptor";
  }
  protected:
  explicit NewFile_FileMetaData_FileDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNumberFieldNumber = 1,
    kFileSizeFieldNumber = 2,
    kSmallestSeqnoFieldNumber = 3,
    kLargestSeqnoFieldNumber = 4,
  };
  // uint64 file_number = 1;
  void clear_file_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_number() const;
  void set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_number() const;
  void _internal_set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 file_size = 2;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 smallest_seqno = 3;
  bool has_smallest_seqno() const;
  private:
  bool _internal_has_smallest_seqno() const;
  public:
  void clear_smallest_seqno();
  ::PROTOBUF_NAMESPACE_ID::uint64 smallest_seqno() const;
  void set_smallest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_smallest_seqno() const;
  void _internal_set_smallest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 largest_seqno = 4;
  bool has_largest_seqno() const;
  private:
  bool _internal_has_largest_seqno() const;
  public:
  void clear_largest_seqno();
  ::PROTOBUF_NAMESPACE_ID::uint64 largest_seqno() const;
  void set_largest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_largest_seqno() const;
  void _internal_set_largest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:logapply.NewFile.FileMetaData.FileDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_number_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 smallest_seqno_;
  ::PROTOBUF_NAMESPACE_ID::uint64 largest_seqno_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class NewFile_FileMetaData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.NewFile.FileMetaData) */ {
 public:
  inline NewFile_FileMetaData() : NewFile_FileMetaData(nullptr) {}
  virtual ~NewFile_FileMetaData();

  NewFile_FileMetaData(const NewFile_FileMetaData& from);
  NewFile_FileMetaData(NewFile_FileMetaData&& from) noexcept
    : NewFile_FileMetaData() {
    *this = ::std::move(from);
  }

  inline NewFile_FileMetaData& operator=(const NewFile_FileMetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewFile_FileMetaData& operator=(NewFile_FileMetaData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewFile_FileMetaData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewFile_FileMetaData* internal_default_instance() {
    return reinterpret_cast<const NewFile_FileMetaData*>(
               &_NewFile_FileMetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NewFile_FileMetaData& a, NewFile_FileMetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(NewFile_FileMetaData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewFile_FileMetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewFile_FileMetaData* New() const final {
    return CreateMaybeMessage<NewFile_FileMetaData>(nullptr);
  }

  NewFile_FileMetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewFile_FileMetaData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewFile_FileMetaData& from);
  void MergeFrom(const NewFile_FileMetaData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewFile_FileMetaData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.NewFile.FileMetaData";
  }
  protected:
  explicit NewFile_FileMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NewFile_FileMetaData_FileDescriptor FileDescriptor;

  // accessors -------------------------------------------------------

  enum : int {
    kSmallestKeyFieldNumber = 2,
    kLargestKeyFieldNumber = 3,
    kFileChecksumFieldNumber = 6,
    kFileChecksumFuncNameFieldNumber = 7,
    kFdFieldNumber = 1,
    kOldestAncestorTimeFieldNumber = 4,
    kFileCreationTimeFieldNumber = 5,
  };
  // string smallest_key = 2;
  void clear_smallest_key();
  const std::string& smallest_key() const;
  void set_smallest_key(const std::string& value);
  void set_smallest_key(std::string&& value);
  void set_smallest_key(const char* value);
  void set_smallest_key(const char* value, size_t size);
  std::string* mutable_smallest_key();
  std::string* release_smallest_key();
  void set_allocated_smallest_key(std::string* smallest_key);
  private:
  const std::string& _internal_smallest_key() const;
  void _internal_set_smallest_key(const std::string& value);
  std::string* _internal_mutable_smallest_key();
  public:

  // string largest_key = 3;
  void clear_largest_key();
  const std::string& largest_key() const;
  void set_largest_key(const std::string& value);
  void set_largest_key(std::string&& value);
  void set_largest_key(const char* value);
  void set_largest_key(const char* value, size_t size);
  std::string* mutable_largest_key();
  std::string* release_largest_key();
  void set_allocated_largest_key(std::string* largest_key);
  private:
  const std::string& _internal_largest_key() const;
  void _internal_set_largest_key(const std::string& value);
  std::string* _internal_mutable_largest_key();
  public:

  // string file_checksum = 6;
  bool has_file_checksum() const;
  private:
  bool _internal_has_file_checksum() const;
  public:
  void clear_file_checksum();
  const std::string& file_checksum() const;
  void set_file_checksum(const std::string& value);
  void set_file_checksum(std::string&& value);
  void set_file_checksum(const char* value);
  void set_file_checksum(const char* value, size_t size);
  std::string* mutable_file_checksum();
  std::string* release_file_checksum();
  void set_allocated_file_checksum(std::string* file_checksum);
  private:
  const std::string& _internal_file_checksum() const;
  void _internal_set_file_checksum(const std::string& value);
  std::string* _internal_mutable_file_checksum();
  public:

  // string file_checksum_func_name = 7;
  bool has_file_checksum_func_name() const;
  private:
  bool _internal_has_file_checksum_func_name() const;
  public:
  void clear_file_checksum_func_name();
  const std::string& file_checksum_func_name() const;
  void set_file_checksum_func_name(const std::string& value);
  void set_file_checksum_func_name(std::string&& value);
  void set_file_checksum_func_name(const char* value);
  void set_file_checksum_func_name(const char* value, size_t size);
  std::string* mutable_file_checksum_func_name();
  std::string* release_file_checksum_func_name();
  void set_allocated_file_checksum_func_name(std::string* file_checksum_func_name);
  private:
  const std::string& _internal_file_checksum_func_name() const;
  void _internal_set_file_checksum_func_name(const std::string& value);
  std::string* _internal_mutable_file_checksum_func_name();
  public:

  // .logapply.NewFile.FileMetaData.FileDescriptor fd = 1;
  bool has_fd() const;
  private:
  bool _internal_has_fd() const;
  public:
  void clear_fd();
  const ::logapply::NewFile_FileMetaData_FileDescriptor& fd() const;
  ::logapply::NewFile_FileMetaData_FileDescriptor* release_fd();
  ::logapply::NewFile_FileMetaData_FileDescriptor* mutable_fd();
  void set_allocated_fd(::logapply::NewFile_FileMetaData_FileDescriptor* fd);
  private:
  const ::logapply::NewFile_FileMetaData_FileDescriptor& _internal_fd() const;
  ::logapply::NewFile_FileMetaData_FileDescriptor* _internal_mutable_fd();
  public:
  void unsafe_arena_set_allocated_fd(
      ::logapply::NewFile_FileMetaData_FileDescriptor* fd);
  ::logapply::NewFile_FileMetaData_FileDescriptor* unsafe_arena_release_fd();

  // uint64 oldest_ancestor_time = 4;
  bool has_oldest_ancestor_time() const;
  private:
  bool _internal_has_oldest_ancestor_time() const;
  public:
  void clear_oldest_ancestor_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 oldest_ancestor_time() const;
  void set_oldest_ancestor_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_oldest_ancestor_time() const;
  void _internal_set_oldest_ancestor_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 file_creation_time = 5;
  bool has_file_creation_time() const;
  private:
  bool _internal_has_file_creation_time() const;
  public:
  void clear_file_creation_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_creation_time() const;
  void set_file_creation_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_creation_time() const;
  void _internal_set_file_creation_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:logapply.NewFile.FileMetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smallest_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr largest_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_checksum_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_checksum_func_name_;
  ::logapply::NewFile_FileMetaData_FileDescriptor* fd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 oldest_ancestor_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_creation_time_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class NewFile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.NewFile) */ {
 public:
  inline NewFile() : NewFile(nullptr) {}
  virtual ~NewFile();

  NewFile(const NewFile& from);
  NewFile(NewFile&& from) noexcept
    : NewFile() {
    *this = ::std::move(from);
  }

  inline NewFile& operator=(const NewFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewFile& operator=(NewFile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewFile* internal_default_instance() {
    return reinterpret_cast<const NewFile*>(
               &_NewFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NewFile& a, NewFile& b) {
    a.Swap(&b);
  }
  inline void Swap(NewFile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewFile* New() const final {
    return CreateMaybeMessage<NewFile>(nullptr);
  }

  NewFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewFile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewFile& from);
  void MergeFrom(const NewFile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewFile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.NewFile";
  }
  protected:
  explicit NewFile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NewFile_FileMetaData FileMetaData;

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // .logapply.NewFile.FileMetaData meta = 2;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::logapply::NewFile_FileMetaData& meta() const;
  ::logapply::NewFile_FileMetaData* release_meta();
  ::logapply::NewFile_FileMetaData* mutable_meta();
  void set_allocated_meta(::logapply::NewFile_FileMetaData* meta);
  private:
  const ::logapply::NewFile_FileMetaData& _internal_meta() const;
  ::logapply::NewFile_FileMetaData* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::logapply::NewFile_FileMetaData* meta);
  ::logapply::NewFile_FileMetaData* unsafe_arena_release_meta();

  // int32 level = 1;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:logapply.NewFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::logapply::NewFile_FileMetaData* meta_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class NewFiles PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.NewFiles) */ {
 public:
  inline NewFiles() : NewFiles(nullptr) {}
  virtual ~NewFiles();

  NewFiles(const NewFiles& from);
  NewFiles(NewFiles&& from) noexcept
    : NewFiles() {
    *this = ::std::move(from);
  }

  inline NewFiles& operator=(const NewFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewFiles& operator=(NewFiles&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewFiles* internal_default_instance() {
    return reinterpret_cast<const NewFiles*>(
               &_NewFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NewFiles& a, NewFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(NewFiles* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewFiles* New() const final {
    return CreateMaybeMessage<NewFiles>(nullptr);
  }

  NewFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewFiles>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewFiles& from);
  void MergeFrom(const NewFiles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewFiles* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.NewFiles";
  }
  protected:
  explicit NewFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewFieldNumber = 1,
  };
  // repeated .logapply.NewFile new = 1;
  int new__size() const;
  private:
  int _internal_new__size() const;
  public:
  void clear_new_();
  ::logapply::NewFile* mutable_new_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::NewFile >*
      mutable_new_();
  private:
  const ::logapply::NewFile& _internal_new_(int index) const;
  ::logapply::NewFile* _internal_add_new_();
  public:
  const ::logapply::NewFile& new_(int index) const;
  ::logapply::NewFile* add_new_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::NewFile >&
      new_() const;

  // @@protoc_insertion_point(class_scope:logapply.NewFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::NewFile > new__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class DeleteFile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.DeleteFile) */ {
 public:
  inline DeleteFile() : DeleteFile(nullptr) {}
  virtual ~DeleteFile();

  DeleteFile(const DeleteFile& from);
  DeleteFile(DeleteFile&& from) noexcept
    : DeleteFile() {
    *this = ::std::move(from);
  }

  inline DeleteFile& operator=(const DeleteFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFile& operator=(DeleteFile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteFile* internal_default_instance() {
    return reinterpret_cast<const DeleteFile*>(
               &_DeleteFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteFile& a, DeleteFile& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteFile* New() const final {
    return CreateMaybeMessage<DeleteFile>(nullptr);
  }

  DeleteFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteFile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteFile& from);
  void MergeFrom(const DeleteFile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.DeleteFile";
  }
  protected:
  explicit DeleteFile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNumberFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // uint64 file_number = 2;
  void clear_file_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_number() const;
  void set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_number() const;
  void _internal_set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 level = 1;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:logapply.DeleteFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// -------------------------------------------------------------------

class DeleteFiles PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logapply.DeleteFiles) */ {
 public:
  inline DeleteFiles() : DeleteFiles(nullptr) {}
  virtual ~DeleteFiles();

  DeleteFiles(const DeleteFiles& from);
  DeleteFiles(DeleteFiles&& from) noexcept
    : DeleteFiles() {
    *this = ::std::move(from);
  }

  inline DeleteFiles& operator=(const DeleteFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFiles& operator=(DeleteFiles&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteFiles* internal_default_instance() {
    return reinterpret_cast<const DeleteFiles*>(
               &_DeleteFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteFiles& a, DeleteFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFiles* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteFiles* New() const final {
    return CreateMaybeMessage<DeleteFiles>(nullptr);
  }

  DeleteFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteFiles>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteFiles& from);
  void MergeFrom(const DeleteFiles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFiles* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logapply.DeleteFiles";
  }
  protected:
  explicit DeleteFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logAndApply_2eproto);
    return ::descriptor_table_logAndApply_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelFieldNumber = 1,
  };
  // repeated .logapply.DeleteFile del = 1;
  int del_size() const;
  private:
  int _internal_del_size() const;
  public:
  void clear_del();
  ::logapply::DeleteFile* mutable_del(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::DeleteFile >*
      mutable_del();
  private:
  const ::logapply::DeleteFile& _internal_del(int index) const;
  ::logapply::DeleteFile* _internal_add_del();
  public:
  const ::logapply::DeleteFile& del(int index) const;
  ::logapply::DeleteFile* add_del();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::DeleteFile >&
      del() const;

  // @@protoc_insertion_point(class_scope:logapply.DeleteFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::DeleteFile > del_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logAndApply_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Response

// bool ok = 1;
inline void Response::clear_ok() {
  ok_ = false;
}
inline bool Response::_internal_ok() const {
  return ok_;
}
inline bool Response::ok() const {
  // @@protoc_insertion_point(field_get:logapply.Response.ok)
  return _internal_ok();
}
inline void Response::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void Response::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:logapply.Response.ok)
}

// -------------------------------------------------------------------

// EditLists_EditList_VersionEdit

// .logapply.NewFiles added = 1;
inline bool EditLists_EditList_VersionEdit::_internal_has_added() const {
  return this != internal_default_instance() && added_ != nullptr;
}
inline bool EditLists_EditList_VersionEdit::has_added() const {
  return _internal_has_added();
}
inline void EditLists_EditList_VersionEdit::clear_added() {
  if (GetArena() == nullptr && added_ != nullptr) {
    delete added_;
  }
  added_ = nullptr;
}
inline const ::logapply::NewFiles& EditLists_EditList_VersionEdit::_internal_added() const {
  const ::logapply::NewFiles* p = added_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logapply::NewFiles*>(
      &::logapply::_NewFiles_default_instance_);
}
inline const ::logapply::NewFiles& EditLists_EditList_VersionEdit::added() const {
  // @@protoc_insertion_point(field_get:logapply.EditLists.EditList.VersionEdit.added)
  return _internal_added();
}
inline void EditLists_EditList_VersionEdit::unsafe_arena_set_allocated_added(
    ::logapply::NewFiles* added) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(added_);
  }
  added_ = added;
  if (added) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:logapply.EditLists.EditList.VersionEdit.added)
}
inline ::logapply::NewFiles* EditLists_EditList_VersionEdit::release_added() {
  
  ::logapply::NewFiles* temp = added_;
  added_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logapply::NewFiles* EditLists_EditList_VersionEdit::unsafe_arena_release_added() {
  // @@protoc_insertion_point(field_release:logapply.EditLists.EditList.VersionEdit.added)
  
  ::logapply::NewFiles* temp = added_;
  added_ = nullptr;
  return temp;
}
inline ::logapply::NewFiles* EditLists_EditList_VersionEdit::_internal_mutable_added() {
  
  if (added_ == nullptr) {
    auto* p = CreateMaybeMessage<::logapply::NewFiles>(GetArena());
    added_ = p;
  }
  return added_;
}
inline ::logapply::NewFiles* EditLists_EditList_VersionEdit::mutable_added() {
  // @@protoc_insertion_point(field_mutable:logapply.EditLists.EditList.VersionEdit.added)
  return _internal_mutable_added();
}
inline void EditLists_EditList_VersionEdit::set_allocated_added(::logapply::NewFiles* added) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete added_;
  }
  if (added) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(added);
    if (message_arena != submessage_arena) {
      added = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, added, submessage_arena);
    }
    
  } else {
    
  }
  added_ = added;
  // @@protoc_insertion_point(field_set_allocated:logapply.EditLists.EditList.VersionEdit.added)
}

// .logapply.DeleteFiles dels = 2;
inline bool EditLists_EditList_VersionEdit::_internal_has_dels() const {
  return this != internal_default_instance() && dels_ != nullptr;
}
inline bool EditLists_EditList_VersionEdit::has_dels() const {
  return _internal_has_dels();
}
inline void EditLists_EditList_VersionEdit::clear_dels() {
  if (GetArena() == nullptr && dels_ != nullptr) {
    delete dels_;
  }
  dels_ = nullptr;
}
inline const ::logapply::DeleteFiles& EditLists_EditList_VersionEdit::_internal_dels() const {
  const ::logapply::DeleteFiles* p = dels_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logapply::DeleteFiles*>(
      &::logapply::_DeleteFiles_default_instance_);
}
inline const ::logapply::DeleteFiles& EditLists_EditList_VersionEdit::dels() const {
  // @@protoc_insertion_point(field_get:logapply.EditLists.EditList.VersionEdit.dels)
  return _internal_dels();
}
inline void EditLists_EditList_VersionEdit::unsafe_arena_set_allocated_dels(
    ::logapply::DeleteFiles* dels) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dels_);
  }
  dels_ = dels;
  if (dels) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:logapply.EditLists.EditList.VersionEdit.dels)
}
inline ::logapply::DeleteFiles* EditLists_EditList_VersionEdit::release_dels() {
  
  ::logapply::DeleteFiles* temp = dels_;
  dels_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logapply::DeleteFiles* EditLists_EditList_VersionEdit::unsafe_arena_release_dels() {
  // @@protoc_insertion_point(field_release:logapply.EditLists.EditList.VersionEdit.dels)
  
  ::logapply::DeleteFiles* temp = dels_;
  dels_ = nullptr;
  return temp;
}
inline ::logapply::DeleteFiles* EditLists_EditList_VersionEdit::_internal_mutable_dels() {
  
  if (dels_ == nullptr) {
    auto* p = CreateMaybeMessage<::logapply::DeleteFiles>(GetArena());
    dels_ = p;
  }
  return dels_;
}
inline ::logapply::DeleteFiles* EditLists_EditList_VersionEdit::mutable_dels() {
  // @@protoc_insertion_point(field_mutable:logapply.EditLists.EditList.VersionEdit.dels)
  return _internal_mutable_dels();
}
inline void EditLists_EditList_VersionEdit::set_allocated_dels(::logapply::DeleteFiles* dels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dels_;
  }
  if (dels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dels);
    if (message_arena != submessage_arena) {
      dels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dels, submessage_arena);
    }
    
  } else {
    
  }
  dels_ = dels;
  // @@protoc_insertion_point(field_set_allocated:logapply.EditLists.EditList.VersionEdit.dels)
}

// -------------------------------------------------------------------

// EditLists_EditList

// repeated .logapply.EditLists.EditList.VersionEdit version_edit = 1;
inline int EditLists_EditList::_internal_version_edit_size() const {
  return version_edit_.size();
}
inline int EditLists_EditList::version_edit_size() const {
  return _internal_version_edit_size();
}
inline void EditLists_EditList::clear_version_edit() {
  version_edit_.Clear();
}
inline ::logapply::EditLists_EditList_VersionEdit* EditLists_EditList::mutable_version_edit(int index) {
  // @@protoc_insertion_point(field_mutable:logapply.EditLists.EditList.version_edit)
  return version_edit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList_VersionEdit >*
EditLists_EditList::mutable_version_edit() {
  // @@protoc_insertion_point(field_mutable_list:logapply.EditLists.EditList.version_edit)
  return &version_edit_;
}
inline const ::logapply::EditLists_EditList_VersionEdit& EditLists_EditList::_internal_version_edit(int index) const {
  return version_edit_.Get(index);
}
inline const ::logapply::EditLists_EditList_VersionEdit& EditLists_EditList::version_edit(int index) const {
  // @@protoc_insertion_point(field_get:logapply.EditLists.EditList.version_edit)
  return _internal_version_edit(index);
}
inline ::logapply::EditLists_EditList_VersionEdit* EditLists_EditList::_internal_add_version_edit() {
  return version_edit_.Add();
}
inline ::logapply::EditLists_EditList_VersionEdit* EditLists_EditList::add_version_edit() {
  // @@protoc_insertion_point(field_add:logapply.EditLists.EditList.version_edit)
  return _internal_add_version_edit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList_VersionEdit >&
EditLists_EditList::version_edit() const {
  // @@protoc_insertion_point(field_list:logapply.EditLists.EditList.version_edit)
  return version_edit_;
}

// -------------------------------------------------------------------

// EditLists

// repeated .logapply.EditLists.EditList edit_list = 1;
inline int EditLists::_internal_edit_list_size() const {
  return edit_list_.size();
}
inline int EditLists::edit_list_size() const {
  return _internal_edit_list_size();
}
inline void EditLists::clear_edit_list() {
  edit_list_.Clear();
}
inline ::logapply::EditLists_EditList* EditLists::mutable_edit_list(int index) {
  // @@protoc_insertion_point(field_mutable:logapply.EditLists.edit_list)
  return edit_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList >*
EditLists::mutable_edit_list() {
  // @@protoc_insertion_point(field_mutable_list:logapply.EditLists.edit_list)
  return &edit_list_;
}
inline const ::logapply::EditLists_EditList& EditLists::_internal_edit_list(int index) const {
  return edit_list_.Get(index);
}
inline const ::logapply::EditLists_EditList& EditLists::edit_list(int index) const {
  // @@protoc_insertion_point(field_get:logapply.EditLists.edit_list)
  return _internal_edit_list(index);
}
inline ::logapply::EditLists_EditList* EditLists::_internal_add_edit_list() {
  return edit_list_.Add();
}
inline ::logapply::EditLists_EditList* EditLists::add_edit_list() {
  // @@protoc_insertion_point(field_add:logapply.EditLists.edit_list)
  return _internal_add_edit_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::EditLists_EditList >&
EditLists::edit_list() const {
  // @@protoc_insertion_point(field_list:logapply.EditLists.edit_list)
  return edit_list_;
}

// -------------------------------------------------------------------

// NewFile_FileMetaData_FileDescriptor

// uint64 file_number = 1;
inline void NewFile_FileMetaData_FileDescriptor::clear_file_number() {
  file_number_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::_internal_file_number() const {
  return file_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::file_number() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.FileDescriptor.file_number)
  return _internal_file_number();
}
inline void NewFile_FileMetaData_FileDescriptor::_internal_set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_number_ = value;
}
inline void NewFile_FileMetaData_FileDescriptor::set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_number(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.FileDescriptor.file_number)
}

// uint64 file_size = 2;
inline void NewFile_FileMetaData_FileDescriptor::clear_file_size() {
  file_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::file_size() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.FileDescriptor.file_size)
  return _internal_file_size();
}
inline void NewFile_FileMetaData_FileDescriptor::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_size_ = value;
}
inline void NewFile_FileMetaData_FileDescriptor::set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.FileDescriptor.file_size)
}

// uint64 smallest_seqno = 3;
inline bool NewFile_FileMetaData_FileDescriptor::_internal_has_smallest_seqno() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewFile_FileMetaData_FileDescriptor::has_smallest_seqno() const {
  return _internal_has_smallest_seqno();
}
inline void NewFile_FileMetaData_FileDescriptor::clear_smallest_seqno() {
  smallest_seqno_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::_internal_smallest_seqno() const {
  return smallest_seqno_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::smallest_seqno() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.FileDescriptor.smallest_seqno)
  return _internal_smallest_seqno();
}
inline void NewFile_FileMetaData_FileDescriptor::_internal_set_smallest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  smallest_seqno_ = value;
}
inline void NewFile_FileMetaData_FileDescriptor::set_smallest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_smallest_seqno(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.FileDescriptor.smallest_seqno)
}

// uint64 largest_seqno = 4;
inline bool NewFile_FileMetaData_FileDescriptor::_internal_has_largest_seqno() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewFile_FileMetaData_FileDescriptor::has_largest_seqno() const {
  return _internal_has_largest_seqno();
}
inline void NewFile_FileMetaData_FileDescriptor::clear_largest_seqno() {
  largest_seqno_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::_internal_largest_seqno() const {
  return largest_seqno_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData_FileDescriptor::largest_seqno() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.FileDescriptor.largest_seqno)
  return _internal_largest_seqno();
}
inline void NewFile_FileMetaData_FileDescriptor::_internal_set_largest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  largest_seqno_ = value;
}
inline void NewFile_FileMetaData_FileDescriptor::set_largest_seqno(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_largest_seqno(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.FileDescriptor.largest_seqno)
}

// -------------------------------------------------------------------

// NewFile_FileMetaData

// .logapply.NewFile.FileMetaData.FileDescriptor fd = 1;
inline bool NewFile_FileMetaData::_internal_has_fd() const {
  return this != internal_default_instance() && fd_ != nullptr;
}
inline bool NewFile_FileMetaData::has_fd() const {
  return _internal_has_fd();
}
inline void NewFile_FileMetaData::clear_fd() {
  if (GetArena() == nullptr && fd_ != nullptr) {
    delete fd_;
  }
  fd_ = nullptr;
}
inline const ::logapply::NewFile_FileMetaData_FileDescriptor& NewFile_FileMetaData::_internal_fd() const {
  const ::logapply::NewFile_FileMetaData_FileDescriptor* p = fd_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logapply::NewFile_FileMetaData_FileDescriptor*>(
      &::logapply::_NewFile_FileMetaData_FileDescriptor_default_instance_);
}
inline const ::logapply::NewFile_FileMetaData_FileDescriptor& NewFile_FileMetaData::fd() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.fd)
  return _internal_fd();
}
inline void NewFile_FileMetaData::unsafe_arena_set_allocated_fd(
    ::logapply::NewFile_FileMetaData_FileDescriptor* fd) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fd_);
  }
  fd_ = fd;
  if (fd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:logapply.NewFile.FileMetaData.fd)
}
inline ::logapply::NewFile_FileMetaData_FileDescriptor* NewFile_FileMetaData::release_fd() {
  
  ::logapply::NewFile_FileMetaData_FileDescriptor* temp = fd_;
  fd_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logapply::NewFile_FileMetaData_FileDescriptor* NewFile_FileMetaData::unsafe_arena_release_fd() {
  // @@protoc_insertion_point(field_release:logapply.NewFile.FileMetaData.fd)
  
  ::logapply::NewFile_FileMetaData_FileDescriptor* temp = fd_;
  fd_ = nullptr;
  return temp;
}
inline ::logapply::NewFile_FileMetaData_FileDescriptor* NewFile_FileMetaData::_internal_mutable_fd() {
  
  if (fd_ == nullptr) {
    auto* p = CreateMaybeMessage<::logapply::NewFile_FileMetaData_FileDescriptor>(GetArena());
    fd_ = p;
  }
  return fd_;
}
inline ::logapply::NewFile_FileMetaData_FileDescriptor* NewFile_FileMetaData::mutable_fd() {
  // @@protoc_insertion_point(field_mutable:logapply.NewFile.FileMetaData.fd)
  return _internal_mutable_fd();
}
inline void NewFile_FileMetaData::set_allocated_fd(::logapply::NewFile_FileMetaData_FileDescriptor* fd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fd_;
  }
  if (fd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fd);
    if (message_arena != submessage_arena) {
      fd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fd, submessage_arena);
    }
    
  } else {
    
  }
  fd_ = fd;
  // @@protoc_insertion_point(field_set_allocated:logapply.NewFile.FileMetaData.fd)
}

// string smallest_key = 2;
inline void NewFile_FileMetaData::clear_smallest_key() {
  smallest_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NewFile_FileMetaData::smallest_key() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.smallest_key)
  return _internal_smallest_key();
}
inline void NewFile_FileMetaData::set_smallest_key(const std::string& value) {
  _internal_set_smallest_key(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.smallest_key)
}
inline std::string* NewFile_FileMetaData::mutable_smallest_key() {
  // @@protoc_insertion_point(field_mutable:logapply.NewFile.FileMetaData.smallest_key)
  return _internal_mutable_smallest_key();
}
inline const std::string& NewFile_FileMetaData::_internal_smallest_key() const {
  return smallest_key_.Get();
}
inline void NewFile_FileMetaData::_internal_set_smallest_key(const std::string& value) {
  
  smallest_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NewFile_FileMetaData::set_smallest_key(std::string&& value) {
  
  smallest_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:logapply.NewFile.FileMetaData.smallest_key)
}
inline void NewFile_FileMetaData::set_smallest_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  smallest_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:logapply.NewFile.FileMetaData.smallest_key)
}
inline void NewFile_FileMetaData::set_smallest_key(const char* value,
    size_t size) {
  
  smallest_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:logapply.NewFile.FileMetaData.smallest_key)
}
inline std::string* NewFile_FileMetaData::_internal_mutable_smallest_key() {
  
  return smallest_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NewFile_FileMetaData::release_smallest_key() {
  // @@protoc_insertion_point(field_release:logapply.NewFile.FileMetaData.smallest_key)
  return smallest_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewFile_FileMetaData::set_allocated_smallest_key(std::string* smallest_key) {
  if (smallest_key != nullptr) {
    
  } else {
    
  }
  smallest_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smallest_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:logapply.NewFile.FileMetaData.smallest_key)
}

// string largest_key = 3;
inline void NewFile_FileMetaData::clear_largest_key() {
  largest_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NewFile_FileMetaData::largest_key() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.largest_key)
  return _internal_largest_key();
}
inline void NewFile_FileMetaData::set_largest_key(const std::string& value) {
  _internal_set_largest_key(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.largest_key)
}
inline std::string* NewFile_FileMetaData::mutable_largest_key() {
  // @@protoc_insertion_point(field_mutable:logapply.NewFile.FileMetaData.largest_key)
  return _internal_mutable_largest_key();
}
inline const std::string& NewFile_FileMetaData::_internal_largest_key() const {
  return largest_key_.Get();
}
inline void NewFile_FileMetaData::_internal_set_largest_key(const std::string& value) {
  
  largest_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NewFile_FileMetaData::set_largest_key(std::string&& value) {
  
  largest_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:logapply.NewFile.FileMetaData.largest_key)
}
inline void NewFile_FileMetaData::set_largest_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  largest_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:logapply.NewFile.FileMetaData.largest_key)
}
inline void NewFile_FileMetaData::set_largest_key(const char* value,
    size_t size) {
  
  largest_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:logapply.NewFile.FileMetaData.largest_key)
}
inline std::string* NewFile_FileMetaData::_internal_mutable_largest_key() {
  
  return largest_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NewFile_FileMetaData::release_largest_key() {
  // @@protoc_insertion_point(field_release:logapply.NewFile.FileMetaData.largest_key)
  return largest_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewFile_FileMetaData::set_allocated_largest_key(std::string* largest_key) {
  if (largest_key != nullptr) {
    
  } else {
    
  }
  largest_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), largest_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:logapply.NewFile.FileMetaData.largest_key)
}

// uint64 oldest_ancestor_time = 4;
inline bool NewFile_FileMetaData::_internal_has_oldest_ancestor_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewFile_FileMetaData::has_oldest_ancestor_time() const {
  return _internal_has_oldest_ancestor_time();
}
inline void NewFile_FileMetaData::clear_oldest_ancestor_time() {
  oldest_ancestor_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData::_internal_oldest_ancestor_time() const {
  return oldest_ancestor_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData::oldest_ancestor_time() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.oldest_ancestor_time)
  return _internal_oldest_ancestor_time();
}
inline void NewFile_FileMetaData::_internal_set_oldest_ancestor_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  oldest_ancestor_time_ = value;
}
inline void NewFile_FileMetaData::set_oldest_ancestor_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_oldest_ancestor_time(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.oldest_ancestor_time)
}

// uint64 file_creation_time = 5;
inline bool NewFile_FileMetaData::_internal_has_file_creation_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewFile_FileMetaData::has_file_creation_time() const {
  return _internal_has_file_creation_time();
}
inline void NewFile_FileMetaData::clear_file_creation_time() {
  file_creation_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData::_internal_file_creation_time() const {
  return file_creation_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewFile_FileMetaData::file_creation_time() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.file_creation_time)
  return _internal_file_creation_time();
}
inline void NewFile_FileMetaData::_internal_set_file_creation_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  file_creation_time_ = value;
}
inline void NewFile_FileMetaData::set_file_creation_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_creation_time(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.file_creation_time)
}

// string file_checksum = 6;
inline bool NewFile_FileMetaData::_internal_has_file_checksum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewFile_FileMetaData::has_file_checksum() const {
  return _internal_has_file_checksum();
}
inline void NewFile_FileMetaData::clear_file_checksum() {
  file_checksum_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NewFile_FileMetaData::file_checksum() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.file_checksum)
  return _internal_file_checksum();
}
inline void NewFile_FileMetaData::set_file_checksum(const std::string& value) {
  _internal_set_file_checksum(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.file_checksum)
}
inline std::string* NewFile_FileMetaData::mutable_file_checksum() {
  // @@protoc_insertion_point(field_mutable:logapply.NewFile.FileMetaData.file_checksum)
  return _internal_mutable_file_checksum();
}
inline const std::string& NewFile_FileMetaData::_internal_file_checksum() const {
  return file_checksum_.Get();
}
inline void NewFile_FileMetaData::_internal_set_file_checksum(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_checksum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NewFile_FileMetaData::set_file_checksum(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  file_checksum_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:logapply.NewFile.FileMetaData.file_checksum)
}
inline void NewFile_FileMetaData::set_file_checksum(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  file_checksum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:logapply.NewFile.FileMetaData.file_checksum)
}
inline void NewFile_FileMetaData::set_file_checksum(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  file_checksum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:logapply.NewFile.FileMetaData.file_checksum)
}
inline std::string* NewFile_FileMetaData::_internal_mutable_file_checksum() {
  _has_bits_[0] |= 0x00000001u;
  return file_checksum_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NewFile_FileMetaData::release_file_checksum() {
  // @@protoc_insertion_point(field_release:logapply.NewFile.FileMetaData.file_checksum)
  if (!_internal_has_file_checksum()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return file_checksum_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewFile_FileMetaData::set_allocated_file_checksum(std::string* file_checksum) {
  if (file_checksum != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_checksum_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_checksum,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:logapply.NewFile.FileMetaData.file_checksum)
}

// string file_checksum_func_name = 7;
inline bool NewFile_FileMetaData::_internal_has_file_checksum_func_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewFile_FileMetaData::has_file_checksum_func_name() const {
  return _internal_has_file_checksum_func_name();
}
inline void NewFile_FileMetaData::clear_file_checksum_func_name() {
  file_checksum_func_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NewFile_FileMetaData::file_checksum_func_name() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.FileMetaData.file_checksum_func_name)
  return _internal_file_checksum_func_name();
}
inline void NewFile_FileMetaData::set_file_checksum_func_name(const std::string& value) {
  _internal_set_file_checksum_func_name(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.FileMetaData.file_checksum_func_name)
}
inline std::string* NewFile_FileMetaData::mutable_file_checksum_func_name() {
  // @@protoc_insertion_point(field_mutable:logapply.NewFile.FileMetaData.file_checksum_func_name)
  return _internal_mutable_file_checksum_func_name();
}
inline const std::string& NewFile_FileMetaData::_internal_file_checksum_func_name() const {
  return file_checksum_func_name_.Get();
}
inline void NewFile_FileMetaData::_internal_set_file_checksum_func_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_checksum_func_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NewFile_FileMetaData::set_file_checksum_func_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  file_checksum_func_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:logapply.NewFile.FileMetaData.file_checksum_func_name)
}
inline void NewFile_FileMetaData::set_file_checksum_func_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  file_checksum_func_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:logapply.NewFile.FileMetaData.file_checksum_func_name)
}
inline void NewFile_FileMetaData::set_file_checksum_func_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  file_checksum_func_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:logapply.NewFile.FileMetaData.file_checksum_func_name)
}
inline std::string* NewFile_FileMetaData::_internal_mutable_file_checksum_func_name() {
  _has_bits_[0] |= 0x00000002u;
  return file_checksum_func_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NewFile_FileMetaData::release_file_checksum_func_name() {
  // @@protoc_insertion_point(field_release:logapply.NewFile.FileMetaData.file_checksum_func_name)
  if (!_internal_has_file_checksum_func_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return file_checksum_func_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewFile_FileMetaData::set_allocated_file_checksum_func_name(std::string* file_checksum_func_name) {
  if (file_checksum_func_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_checksum_func_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_checksum_func_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:logapply.NewFile.FileMetaData.file_checksum_func_name)
}

// -------------------------------------------------------------------

// NewFile

// int32 level = 1;
inline void NewFile::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFile::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFile::level() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.level)
  return _internal_level();
}
inline void NewFile::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void NewFile::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:logapply.NewFile.level)
}

// .logapply.NewFile.FileMetaData meta = 2;
inline bool NewFile::_internal_has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline bool NewFile::has_meta() const {
  return _internal_has_meta();
}
inline void NewFile::clear_meta() {
  if (GetArena() == nullptr && meta_ != nullptr) {
    delete meta_;
  }
  meta_ = nullptr;
}
inline const ::logapply::NewFile_FileMetaData& NewFile::_internal_meta() const {
  const ::logapply::NewFile_FileMetaData* p = meta_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logapply::NewFile_FileMetaData*>(
      &::logapply::_NewFile_FileMetaData_default_instance_);
}
inline const ::logapply::NewFile_FileMetaData& NewFile::meta() const {
  // @@protoc_insertion_point(field_get:logapply.NewFile.meta)
  return _internal_meta();
}
inline void NewFile::unsafe_arena_set_allocated_meta(
    ::logapply::NewFile_FileMetaData* meta) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:logapply.NewFile.meta)
}
inline ::logapply::NewFile_FileMetaData* NewFile::release_meta() {
  
  ::logapply::NewFile_FileMetaData* temp = meta_;
  meta_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logapply::NewFile_FileMetaData* NewFile::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:logapply.NewFile.meta)
  
  ::logapply::NewFile_FileMetaData* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::logapply::NewFile_FileMetaData* NewFile::_internal_mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::logapply::NewFile_FileMetaData>(GetArena());
    meta_ = p;
  }
  return meta_;
}
inline ::logapply::NewFile_FileMetaData* NewFile::mutable_meta() {
  // @@protoc_insertion_point(field_mutable:logapply.NewFile.meta)
  return _internal_mutable_meta();
}
inline void NewFile::set_allocated_meta(::logapply::NewFile_FileMetaData* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:logapply.NewFile.meta)
}

// -------------------------------------------------------------------

// NewFiles

// repeated .logapply.NewFile new = 1;
inline int NewFiles::_internal_new__size() const {
  return new__.size();
}
inline int NewFiles::new__size() const {
  return _internal_new__size();
}
inline void NewFiles::clear_new_() {
  new__.Clear();
}
inline ::logapply::NewFile* NewFiles::mutable_new_(int index) {
  // @@protoc_insertion_point(field_mutable:logapply.NewFiles.new)
  return new__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::NewFile >*
NewFiles::mutable_new_() {
  // @@protoc_insertion_point(field_mutable_list:logapply.NewFiles.new)
  return &new__;
}
inline const ::logapply::NewFile& NewFiles::_internal_new_(int index) const {
  return new__.Get(index);
}
inline const ::logapply::NewFile& NewFiles::new_(int index) const {
  // @@protoc_insertion_point(field_get:logapply.NewFiles.new)
  return _internal_new_(index);
}
inline ::logapply::NewFile* NewFiles::_internal_add_new_() {
  return new__.Add();
}
inline ::logapply::NewFile* NewFiles::add_new_() {
  // @@protoc_insertion_point(field_add:logapply.NewFiles.new)
  return _internal_add_new_();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::NewFile >&
NewFiles::new_() const {
  // @@protoc_insertion_point(field_list:logapply.NewFiles.new)
  return new__;
}

// -------------------------------------------------------------------

// DeleteFile

// int32 level = 1;
inline void DeleteFile::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteFile::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteFile::level() const {
  // @@protoc_insertion_point(field_get:logapply.DeleteFile.level)
  return _internal_level();
}
inline void DeleteFile::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void DeleteFile::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:logapply.DeleteFile.level)
}

// uint64 file_number = 2;
inline void DeleteFile::clear_file_number() {
  file_number_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DeleteFile::_internal_file_number() const {
  return file_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DeleteFile::file_number() const {
  // @@protoc_insertion_point(field_get:logapply.DeleteFile.file_number)
  return _internal_file_number();
}
inline void DeleteFile::_internal_set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  file_number_ = value;
}
inline void DeleteFile::set_file_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_number(value);
  // @@protoc_insertion_point(field_set:logapply.DeleteFile.file_number)
}

// -------------------------------------------------------------------

// DeleteFiles

// repeated .logapply.DeleteFile del = 1;
inline int DeleteFiles::_internal_del_size() const {
  return del_.size();
}
inline int DeleteFiles::del_size() const {
  return _internal_del_size();
}
inline void DeleteFiles::clear_del() {
  del_.Clear();
}
inline ::logapply::DeleteFile* DeleteFiles::mutable_del(int index) {
  // @@protoc_insertion_point(field_mutable:logapply.DeleteFiles.del)
  return del_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::DeleteFile >*
DeleteFiles::mutable_del() {
  // @@protoc_insertion_point(field_mutable_list:logapply.DeleteFiles.del)
  return &del_;
}
inline const ::logapply::DeleteFile& DeleteFiles::_internal_del(int index) const {
  return del_.Get(index);
}
inline const ::logapply::DeleteFile& DeleteFiles::del(int index) const {
  // @@protoc_insertion_point(field_get:logapply.DeleteFiles.del)
  return _internal_del(index);
}
inline ::logapply::DeleteFile* DeleteFiles::_internal_add_del() {
  return del_.Add();
}
inline ::logapply::DeleteFile* DeleteFiles::add_del() {
  // @@protoc_insertion_point(field_add:logapply.DeleteFiles.del)
  return _internal_add_del();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logapply::DeleteFile >&
DeleteFiles::del() const {
  // @@protoc_insertion_point(field_list:logapply.DeleteFiles.del)
  return del_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace logapply

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_logAndApply_2eproto
